---
layout: post
title: Boost serial ports and new C++0x (C++1x) features
---

I recently spent some time writing my first small application on Linux (Ubuntu 10.10 using GCC 4.5 and the Boost libraries). The plan is to try writing some cross-platform, portable C++, while trying out the new C++0x features that have been implemented in GCC 4.5.<br /><br />This application uses the asio (asynchronous I/O) features in the Boost libraries along with the Boost serial_port implementation to read and display input from a serial port (e.g. GPS NMEA data). I also used experimental C++0x threading libraries and lambdas and tried the Boost implementation of the observer pattern - sockets and signals. I have yet to test this code on any other platform.  <br /><br /><h3>main.cpp</h3><pre class="brush:cpp">#include "headers.h"<br />#include "SerialPort.h"<br />using namespace std;<br />using namespace boost::asio;<br /><br />int main()<br />{<br />        //allow inter-mixing of wcout and cout calls (apparently non-standard)<br />        ios::sync_with_stdio(false);<br /><br />        string portName = "/dev/ttyUSB1";<br /><br />        io_service ioService;<br />        io_service::work work(ioService);<br />        thread ioThread([&amp;ioService] () { ioService.run(); });<br /><br />        SerialPort port(portName, 4800, ioService);<br />        port.LineReceived.connect([] (std::vector&lt;char&gt; const &amp; line)<br />            {<br />                cout &lt;&lt; &amp;line[0] &lt;&lt; endl;<br />            });<br /><br />        wcout &lt;&lt; L"Listening on port: " &lt;&lt; endl;<br />        cout &lt;&lt; portName &lt;&lt; endl;<br />        wcout &lt;&lt; L"Press enter to stop listening..." &lt;&lt; endl;<br />        wstring result;<br />        getline(wcin, result);<br />        wcout &lt;&lt; L"Exiting..." &lt;&lt; endl;<br /><br />        ioService.stop();<br />        ioThread.join();<br />}<br /></pre><br /><h3>headers.h</h3><i>Separated for precompilation.</i><br /><pre class="brush:cpp">#include &lt;boost/asio.hpp&gt;<br />#include &lt;boost/signal.hpp&gt;<br />#include &lt;iostream&gt;<br />#include &lt;vector&gt;<br />#include &lt;thread&gt;<br />#include &lt;functional&gt;<br /></pre><br /><h3>SerialPort.h</h3><pre class="brush:cpp">#ifndef SERIALPORT_H<br />#define SERIALPORT_H<br /><br />class SerialPort<br />{<br />public:<br />    SerialPort(std::string const &amp; portName, int portSpeed, boost::asio::io_service &amp; ioService);<br /><br />    boost::signal&lt;void(std::vector&lt;char&gt; const &amp;)&gt; LineReceived;<br /><br />private:<br />    void OnBytesRead(boost::system::error_code const &amp;error, size_t bytesReceived);<br />    void BeginListening();<br /><br />    std::vector&lt;char&gt; _readBuffer;<br />    std::vector&lt;char&gt; _currentLine;<br />    boost::asio::serial_port _port;<br />};<br /><br />#endif // SERIALPORT_H<br /></pre><br /><h3>SerialPort.cpp</h3><pre class="brush:cpp">#include "headers.h"<br />#include "SerialPort.h"<br />using namespace std;<br />using namespace boost::asio;<br /><br />SerialPort::SerialPort(string const &amp; portName, int const portSpeed, io_service &amp; ioService)<br />    : _readBuffer(1000),<br />      _port(ioService, portName)<br /><br />{<br />    _port.set_option(serial_port_base::baud_rate(portSpeed));<br /><br />    BeginListening();<br />}<br /><br />void SerialPort::BeginListening()<br />{<br />    _port.async_read_some(buffer(&amp;_readBuffer[0], _readBuffer.size()),<br />        [this](boost::system::error_code const &amp;error, size_t bytesReceived)<br />        {<br />            this-&gt;OnBytesRead(error, bytesReceived);<br />        });<br />}<br /><br />void SerialPort::OnBytesRead(boost::system::error_code const &amp;error, size_t bytesReceived)<br />{<br />    if(error)<br />    {<br />        return;<br />    }<br /><br />    for(size_t i = 0; i != bytesReceived; ++i)<br />    {<br />        char currentChar = _readBuffer[i];<br />        switch(currentChar)<br />        {<br />        case '\r':<br />            break;<br />        case '\n':<br />            LineReceived(_currentLine);<br />            _currentLine.clear();<br />            break;<br />        default:<br />            _currentLine.push_back(currentChar);<br />        }<br />    }<br /><br />    BeginListening();<br />}<br /></pre>
