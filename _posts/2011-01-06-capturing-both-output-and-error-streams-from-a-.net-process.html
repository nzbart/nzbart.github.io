---
layout: post
title: Capturing both output and error streams from a .NET process
---

MSDN documents a well-known problem that needs to be worked around when reading output from a console process started using System.Diagnostics.Process:<br /><br /><blockquote>The code example avoids a deadlock condition by calling p.StandardOutput.ReadToEnd before p.WaitForExit. A deadlock condition can result if the parent process calls p.WaitForExit before p.StandardOutput.ReadToEnd and the child process writes enough text to fill the redirected stream. The parent process would wait indefinitely for the child process to exit. The child process would wait indefinitely for the parent to read from the full StandardOutput stream.</blockquote><br />The example in MSDN is:<br /><br /><pre class="brush:csharp">// Start the child process.<br /> Process p = new Process();<br /> // Redirect the output stream of the child process.<br /> p.StartInfo.UseShellExecute = false;<br /> p.StartInfo.RedirectStandardOutput = true;<br /> p.StartInfo.FileName = "Write500Lines.exe";<br /> p.Start();<br /> // Do not wait for the child process to exit before<br /> // reading to the end of its redirected stream.<br /> // p.WaitForExit();<br /> // Read the output stream first and then wait.<br /> string output = p.StandardOutput.ReadToEnd();<br /> p.WaitForExit();<br /></pre><br />The problem with this example is that it only reads from stdout - not from stderr. One solution, using the new .NET TPL (Task Parallel Library), is to launch two tasks that read the output and error streams.<br /><br /><pre class="brush:csharp">ProcessStartInfo psInfo = new ProcessStartInfo<br />{<br />    Arguments = @"/c dir C:\",<br />    FileName = @"C:\Windows\system32\cmd.exe",<br />    RedirectStandardOutput = true,<br />    RedirectStandardError = true,<br />    UseShellExecute = false<br />};<br /><br />Process proc = Process.Start(psInfo);<br />string stderr = null, stdin = null;<br />Parallel.Invoke(() => stdin = proc.StandardOutput.ReadToEnd(),<br />    () => stderr = proc.StandardError.ReadToEnd());<br />proc.WaitForExit();<br /></pre><br />There is one caveat with this approach - Parallel.Invoke does not seem to guarantee that both tasks will run in parallel. I will need to investigate this some more.
