---
layout: post
title: Demonstrating the effect of CPU pipelining on performance
---

When writing high performance applications, you may need to understand some of the fundamentals of CPU architecture, such as <a href="http://en.wikipedia.org/wiki/Pipeline_(computing)">CPU pipelining</a>. Often it can be most useful to see the effect of pipelining in a simple example.<br /><br />The full source code for this example is below, but the most important part is the assembly code and results.<br /><br />The test uses the Windows high performance timer to see how long it takes to execute a function written in Intel x64 assembly. <br /><br />The simple loop below sets the rax register to a large number (in this case 2.33 billion, since I am running on a 2.33 GHz processor), and repeatedly decreases it until it hits zero. My console application then printed out the number of milliseconds this took to execute. On my machine, it took roughly 1000 ms to execute, even though it is executing a decrement instruction followed by a jump.<br /><pre class="brush:plain">.CODE             <br /><br />runAssemblyCode PROC<br />  mov rax, 2330 * 1000 * 1000<br /> start:<br />  dec rax<br />  jnz start<br />  ret <br />runAssemblyCode ENDP <br />END<br /></pre><br />To complicate things even more, here I perform more, independent, operations in the same loop. Instead of 1 decrement, I now do 5 on various different registers. The total time taken is only about 2000 milliseconds.<br /><br /><pre class="brush:plain">.CODE             <br /><br />runAssemblyCode PROC<br />  mov rax, 2330 * 1000 * 1000<br /> start:<br />  dec rcx<br />  dec rdx<br />  dec r9<br />  dec r10<br />  dec rax<br />  jnz start<br />  ret <br />runAssemblyCode ENDP <br />END<br /></pre><br />As to the finer details of Intel CPU pipelining, I could not explain how to calculate the expected execution time for these examples, but they do demonstrate quite well that a sequence of carefully crafted instructions can execute faster than the clock speed of your CPU would have you believe.<br /><br />To run this application yourself, simply create a Visual Studio 2010 (or newer) C++ project and create two files - one .ASM file with the assembly above, and one .CPP file with the C++ code below. You will also need to enable the MASM build customisation by right clicking on the project and clicking <i>Build Customisations</i>.<br /><br /><pre class="brush:cpp">#include &lt;Windows.h><br />#include &lt;memory><br />#include &lt;iostream><br /><br />using namespace std;<br /><br />extern "C" void runAssemblyCode();<br /><br />class Timer<br />{<br />public:<br />    Timer()<br />    {<br />        QueryPerformanceFrequency(&_ticksPerSecond);<br />        Reset();<br />    }<br /><br />    void Reset()<br />    {<br />        QueryPerformanceCounter(&_startedAt);<br />    }<br /><br />    long long GetElapsedMilliseconds()<br />    {<br />        LARGE_INTEGER now;<br />        QueryPerformanceCounter(&now);<br />        return (now.QuadPart - _startedAt.QuadPart) * 1000 / _ticksPerSecond.QuadPart;<br />    }<br /><br />private:<br />    LARGE_INTEGER _startedAt;<br />    LARGE_INTEGER _ticksPerSecond;<br />};<br /><br />int wmain(int argc, wchar_t* argv[])<br />{<br />    Timer timer;<br /><br />    runAssemblyCode();<br /><br />    auto elapsed = timer.GetElapsedMilliseconds();<br />    cout << elapsed << endl;<br /><br />    return 0;<br />}<br /></pre>
