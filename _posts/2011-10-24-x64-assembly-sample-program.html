---
layout: post
title: x64 assembly sample program
---

To get a better understanding of how the new <a href="http://msdn.microsoft.com/en-us/library/ms235286(v=vs.80).aspx">Microsoft x64 calling convention</a> works, I thought it would be a good idea to reacquaint myself with assembly language, this time using <i>ml64.exe</i>. While I do not write assembly language in my day-to-day job, I still find it surprisingly useful to be able to read and decipher assembly language. Understanding calling conventions and stack usage are a critical part of being able to debug assembly language.<br /><br />A key takeaway for me from this process is that the x64 convention passes the first four arguments in volatile registers, therefore making it difficult to review the parameters as passed to a function because they will not be stored in memory. Note that space is allocated on the stack for the parameters that are passed via register, but the memory is generally left uninitialised in release-mode builds. The <a href="http://blogs.msdn.com/b/ntdebugging/archive/2009/01/09/challenges-of-debugging-optimized-x64-code.aspx">Advanced Windows Debugging and Troubleshooting blog</a> has a good run-down of the difficulties this poses.<br /><br />Below is a sample program I wrote, along with the command line to compile it:<br /><br /><pre>extrn ExitProcess: PROC <br />extrn MessageBoxA: PROC<br />extrn WriteConsoleA: PROC<br />extrn AllocConsole: PROC<br />extrn GetStdHandle: PROC<br /><br />.data<br />caption db 'x64 Assembly Program', 0<br />message db 'Hello World!', 0<br /><br />.code<br />main proc<br />  sub rsp, (5 + 1 + 1) * 8 ;5 parameters + return + stdhandle + [written length]; <br /><br />  call AllocConsole<br />  test rax, rax<br />  jz error<br /><br />  mov rcx, 0FFFFFFF5h<br />  call GetStdHandle ;eax = handle<br /><br />  mov rcx, rax<br />  lea rdx, message<br />  mov r8, 12 ; length of string<br />  lea r9, [rsp + 6 * 8]<br />  mov qword ptr [rsp + 4 * 8], 0<br /><br />  call WriteConsoleA<br /><br />  call DisplayMessage<br /><br />  add rsp, 56<br />  ret<br /><br />error:<br />  mov rcx, -1<br />  call ExitProcess<br />main endp<br /><br />DisplayMessage proc<br />  sub rsp, 28h<br />  mov   rcx, 0 <br />  lea   rdx, message<br />  lea   r8, caption<br />  mov   r9d, 0<br />  call  MessageBoxA<br />  add   rsp, 28h<br />  ret<br />DisplayMessage endp<br />end<br /></pre><br />This is the command line that can be used to compile the code above:<br /><br /><pre class="brush:ps">ml64.exe /Zi Prog.asm /link /subsystem:windows /defaultlib:kernel32.lib /defaultlib:user32.lib /entry:main<br /></pre><br />Note that, in my installation of Visual Studio 2010, <i>ml64.exe</i> is in the <i>C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\bin\x86_amd64</i> folder. Make sure that you use the x64 version of the Visual Studio command prompt, otherwise the link process will silently fail.
