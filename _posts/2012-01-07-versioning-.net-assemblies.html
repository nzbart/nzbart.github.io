---
layout: post
title: Versioning .NET assemblies
---

<p>Providing meaningful version numbers to PE binaries (.EXEs and .DLLs) is a very good way to make sure that you can always find the correct source code that was used to build. Note that this should be used in conjunction with a <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms680693(v=vs.85).aspx">symbol server</a>, which is so trivially easy to <a href="http://blogs.msdn.com/b/jimlamb/archive/2009/06/15/symbol-and-source-server-in-tfs-2010.aspx">set up in TFS 2010</a> that everyone should be doing it. </p> <p>This is my currently recommended way for using the various versions available in .NET assemblies. Note that it is subject to change as new and better ideas come along!</p> <br /><h3>The AssemblyVersion.cs file</h3><p>Set up a single C# file that you will include in all your assemblies that need to be given the same version number. I currently give all the DLLs in a single releasable product the same version number so future releases of an assembly will have a new version number, regardless of whether any of the code in that DLL has actually changed. I find this the simplest way to ensure consistency of the product through the full SDLC. In this C# file, which could be called AssemblyVersion.cs, your continuous integration (CI) server will generate something like the following code:</p><pre class="brush:csharp">using System.Reflection;<br /><br />[assembly: AssemblyVersion("1.0.2.23456")]<br />[assembly: AssemblyInformationalVersion("1.0.1beta1 ($/Project/Main;223456)")]<br /></pre><p>You will need to put this file in a common location and include it as a linked file in each of your projects. This common file replaces the versioning information that is usually in AssemblyInfo.cs, so you will need to remove those attributes from each project that you include AssemblyVersion.cs in.</p>   <br /><h3>AssemblyVersion.cs in development and production</h3><p>I like to make version number obviously different when building on developer machines, so I typically set the version to 0.0.0.0 or - in case Visual Studio Code Analysis complains - 0.0.0.1. The following AssemblyVersion.cs file would be checked into source control:</p><pre class="brush:csharp"><br />using System.Reflection;<br /><br />[assembly: AssemblyVersion("0.0.0.0")]<br />[assembly: AssemblyInformationalVersion("development")]<br /></pre> And the following PowerShell script would be <a href="http://nzbart.blogspot.com/2010/10/executing-powershell-script-from-tfs.html">launched from within TFS</a>, Jenkins, Cruise Control, or your CI server of choice to modify AssemblyVersion.cs.  <pre class="brush:ps"><br />param(<br />        [parameter(mandatory=$true)][int]$MajorVersion,<br />        [parameter(mandatory=$true)][int]$MinorVersion,<br />        [parameter(mandatory=$true)][int]$SourceRevision,<br />        [parameter(mandatory=$true)][string]$SourceBranch<br />)<br /><br />#validate source parameters<br />if($SourceRevision -lt 0 -or $SourceRevision -gt 6553565535) {<br />    throw "Invalid SourceRevision."<br />}<br />if($MajorVersion -lt 0 -or $MajorVersion -gt 65535 -or $MinorVersion -lt 0 -or $MinorVersion -gt 65535) {<br />    throw "Invalid major / minor version."<br />}<br /><br />$scriptFolder = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent<br />$versionFile = resolve-path (join-path $scriptFolder 'AssemblyVersion.cs') # script must be in the same folder as AssemblyVersion.cs<br /><br />if(-not (test-path $versionFile)) {<br />    throw "Unable to find version file."<br />}<br /><br />#calculate Build/Revision version component<br />if($SourceRevision -le 65535) {<br />    $rev1 = 0<br />    $rev2 = $SourceRevision<br />} <br />else {<br />    $verStr = $SourceRevision.ToString()<br />    $rev2 = [int][string]::Join('', $verStr[-5..-1])<br />    if($rev2 -gt 65535) {<br />        $rev2 = [int][string]::Join('', $verStr[-4..-1])<br />    } <br />    $rev1 = [int]$verStr.SubString(0, $verStr.length - $rev2.ToString().length)<br />}<br /><br />$assemblyVersion = "$MajorVersion.$MinorVersion.$rev1.$rev2"<br />$humanVersion = $SourceBranch + ':' + $SourceRevision<br /><br />Write-Host "Setting assembly version to $assemblyVersion and human readable version to '$humanVersion'."<br /><br />(type $versionFile) -replace '0.0.0.0',$assemblyVersion -replace 'development',$humanVersion | Out-File -Encoding UTF8 $versionFile<br /></pre> <br /><h3>AssemblyVersionAttribute</h3><p>The Assembly version will by default also be set as the AssemblyFileVersion if the latter is not explicitly specified. One important piece of information I want to include is the revision number of the source code that was used to make the build. Each component in the AssemblyVersion is limited to 65535 (16 bit). Since it won't take long for 65535 revisions to be committed when <a href="http://www.codinghorror.com/blog/2008/08/check-in-early-check-in-often.html">checking in early and often</a>, I spill over into the build number in a human readable fashion, so version 1.0 built from revision 223456 would be 1.0.2.23456.</p> <br/><h3>AssemblyInformationalVersionAttribute</h3>The AssemblyInformationalVersion attribute is a very useful free text string that will appear in the Product Version field when looking at the details of the DLL in Windows Explorer. I sometimes use a <a href="http://semver.org/">semantic version</a> as the first part of that string, and always include an unambiguous reference to the source code that was used to build it i.e. branch and revision details for whatever source control system is in use.
